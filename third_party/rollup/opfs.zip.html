# opfs-zip
Is a Framework / Format / Data Structure it implements the .webar 
Designed to implement stealify based applications compiled with the B8G Engine.
The B8G Engine is a Compiler build on top of the V8 Engine implements compiler feedback interfaces
and additional compiler tooling shipping with the  opfs.zip modules for v8 the v8 opfs.zip modules
can be used indipendent or as wasm or compiled with B8G, This again allows maximal Compatability
and code reuse. 

indipendent means c++ and optional ASM any other language integration needs to
export c binary compatiable modules as ASM or clib or compile as sayed before to wasm. Rust can do both. 
While we would highly recommendet point out that rust or crablang how its open fork is called is not usefull
you get memory safty already out of the box for any Language as the B8G Engine Containerises the memory for you.
And it also adds correct bound checking. 

It implements a so called stub method and bundels it with the files to directly deploy run and watch them
based on predefined rules in the stub method that can be conditional based on Environment.

This allows maximal Compatability between runtimes and Context Implementations.
As always the stub method can be replaced by any injected one for debugging needs.

The adviced file format for data shipping is tar containing .gz of raw stubmethod, data arrays delimereted by line
most best that tar file contains a integrity.txt see: markdown.html#!url=documentation/integirty.md 

the format is named usal .webar and represents a ECMAScript Archive which uses WInterOp Standards as default
compatible Environment.

as rule of thumb for c++ use uniq pointrs and cpp20+ if possible use always the safe abstractions over the unsafe.

The WebArchive Format ships with a default stub that implements a minimal linux fuchsia os microkernel and fileSystem based apis

This allows you to treat your Applications as indipendent containers or instances so it is a Web Container format.

do not get misslead by the term WebContainer there is a company that also calls it's product like that but this is not it.

we do not name the other company because it is not so importent they offer only a wasm build of nodejs with limited Compatability
reducing its usefullness to zero as it can do only string processing and emulate a website context on a company supplyed origin. 

the reduction to string processing only is what makes it diffrent to this product as this is fully network capable and also designed
to run in any browser it offers integrations to the TCPOpen,UDPOpen,WebRTC connection API's as also additional extensions and devtool protocol
connections and last but not least process stdin stdout stderr support. 

so a lot of integration methods for existing Operating systems. You can easy switch between operating systems and Environments 
as everything is the same. 

## Why?
Existing solutions did not fit our needs and standards the compile time was to high the excution time and amount of total requests concurrent
was not as high as expected the observability of running processes and debug ability of code was bad overall there was no existing platform we could dependt
on as our base criterias where never matched. 

Also packaging deployment and testing did not fit our standards and needs we needed a solution that works in dev and production to enable us
to do realtime code updates as also get observablity if needed and sync them to all clients as also get controll back over our data. 

we also did not want to switch forth and back between dev and production as our user should be able to audit the code that runs on the systems
we shipping directly the versioned annotatted source. This saves space over time as we only sync changes if needed and we compact it to take up
most time even less space then compared methods that strip the source as we are able to generate a lot of code out of our IR Code that we ship.